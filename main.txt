#include <assert.h>
#include <filesystem>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <string>
#include <vector>

#include "yolov8.h"
#include "yolov8_onnx.h"
#include "yolov8_seg.h"
#include "yolov8_seg_onnx.h"
#include <math.h>
#include <time.h>

using namespace std;
using namespace cv;
using namespace dnn;
namespace fs = std::filesystem;

// number of classes
const int NUM_CLS = 80;

// generate random mask color
static vector<Scalar> color;
static void generate_mask_color() {
  srand(time(0));
  for (int i = 0; i < NUM_CLS; i++) {
    int b = rand() % 256;
    int g = rand() % 256;
    int r = rand() % 256;
    color.push_back(Scalar(b, g, r));
  }
}

/**
\TODO: modify ReadModel to read only once per inference.
*/
template <typename _Tp>
int yolov8(_Tp &cls, cv::Mat &img, cv::dnn::Net& net) {
  std::vector<OutputSeg> result;
  if (cls.Detect(img, net, result)) {
    DrawPred(img, result, cls._className, color);
  } else {
    std::cout << "Detect Failed!" << std::endl;
  }
  return 0;
}
template <typename _Tp>
int yolov8_onnx(_Tp &cls, cv::Mat &img, cv::dnn::Net& net) {
  std::vector<OutputSeg> result;
  if (cls.OnnxDetect(img, net, result)) {
    DrawPred(img, result, cls._className, color);
  } else {
    std::cout << "Detect Failed!" << std::endl;
  }
  return 0;
}

void process_image(cv::dnn::Net& net, const std::string &img_path,
                   const std::string &task) {
  auto entry = fs::directory_entry(img_path);
  assert(entry.is_regular_file() && (entry.path().extension() == ".jpg" ||
                                     entry.path().extension() == ".JPG" ||
                                     entry.path().extension() == ".jpeg" ||
                                     entry.path().extension() == ".JPEG" ||
                                     entry.path().extension() == ".png" ||
                                     entry.path().extension() == ".PNG"));
  cv::Mat img = cv::imread(img_path);
  if (img.empty()) {
    std::cout << "Error: Failed to read image " << img_path << std::endl;
    return;
  }

  // Print progress information
  std::cout << "Processed image: " << img_path << std::endl;
  if (task == "detect") {
    Yolov8 task_detect;
    yolov8(task_detect, img, net);
  } else if (task == "segment") {
    Yolov8Seg task_segment;
    yolov8(task_segment, img, net);
  }
}

void process_image_onnx(Ort::Session &session, const std::string &img_path,
                        const std::string &task) {}

int main(int argc, char *argv[]) {
  std::string input_dir = "../images/";
  std::string task = "segment";
  std::string model_path = "../models/yolov8n-seg-FC5-sim.onnx";
  bool enable_onnxruntime = false;
  bool isCuda = false;
  int cudaID = 0;
  bool warmUp = true;
  for (int i = 1; i < argc; i++) {
    std::string arg = argv[i];
    if (arg == "--task=segment" || arg == "--task=detect") {
      task = arg.substr(arg.find('=') + 1);
    } else if (arg == "--onnx") {
      enable_onnxruntime = true;
    } else if (arg.find("--cuda:") != std::string::npos) {
      isCuda = true;
      cudaID = std::stoi(arg.substr(arg.find(':') + 1));
    } else {
      input_dir = arg;
    }
  }

  cv::dnn::Net net;

  bool readModelSuccess = false;
  if (task == "detect") {
    Yolov8 task_detect;
    Yolov8Onnx task_detect_onnx;
    if (!model_path.empty()) {
      if (enable_onnxruntime) {
        readModelSuccess =
            task_detect_onnx.ReadModel(model_path, isCuda, cudaID, warmUp);
      } else {
        readModelSuccess = task_detect.ReadModel(net, model_path, isCuda);
      }
    }
    if (readModelSuccess) {
      if (enable_onnxruntime) {

      } else {

      }
    } else {
      std::cout << "Error: Failed to read model" << std::endl;
    }
  } else if (task == "segment") {
    Yolov8Seg task_segment;
    Yolov8SegOnnx task_segment_onnx;
    if (!model_path.empty()) {
      if (enable_onnxruntime) {
        readModelSuccess =
            task_segment_onnx.ReadModel(model_path, isCuda, cudaID, warmUp);
      } else {
        readModelSuccess = task_segment.ReadModel(net, model_path, isCuda);
      }
    } else {
      std::cout << "Error: Failed to read model" << std::endl;
    }
  } else {
    std::cout << "Error: Invalid task specified." << std::endl;
  }

  if (input_dir.empty()) {
    std::cout << "Error: No input path or directories specified." << std::endl;
    return 1;
  }

  if (fs::is_directory(input_dir)) {
    // Process all images in the directory
    for (const auto &entry : fs::directory_iterator(input_dir)) {
      process_image(net, entry.path().string(), task);
    }
  } else {
    if (!fs::exists(input_dir)) {
      std::cout << "Error: Input path: " << input_dir << " not found."
                << std::endl;
      return 1;
    }
    // Process single image file
    process_image(net, input_dir, task);
  }

  return 0;
}